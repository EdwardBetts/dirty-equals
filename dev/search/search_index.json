{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Doing dirty (but extremely useful) things with equals. {{ version }} dirty-equals is a python library that (mis)uses the __eq__ method to make python code (generally unit tests) more declarative and therefore easier to read and write. dirty-equals can be used in whatever context you like, but it comes into its own when writing unit tests for applications where you're commonly checking the response to API calls and the contents of a database. Usage \u00b6 Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive # (1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . Not that interesting yet! , but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr def test_user_endpoint ( client : 'HttpClient' , db_conn : 'Database' ): client . pust ( '/users/create/' , data =... ) user_data = db_conn . fetchrow ( 'select * from users' ) assert user_data == { 'id' : IsPositiveInt , # (1)! 'username' : 'samuelcolvin' , # (2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), # (3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), # (4)! 'created_ts' : IsNow ( delta = 3 ), # (5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: IsPartialDict lets you compare a subset of a dictionary IsStrictDict lets you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints nesting any of these types inside any others IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more... Installation \u00b6 Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Introduction"},{"location":"#usage","text":"Here's a trivial example of what dirty-equals can do: Trival Usage from dirty_equals import IsPositive assert 1 == IsPositive # (1)! assert - 2 == IsPositive # this will fail! (2) This assert will pass since 1 is indeed positive, so the result of 1 == IsPositive is True . This will fail (raise a AssertionError ) since -2 is not positive, so the result of -2 == IsPositive is False . Not that interesting yet! , but consider the following unit test code using dirty-equals : More Powerful Usage from dirty_equals import IsJson , IsNow , IsPositiveInt , IsStr def test_user_endpoint ( client : 'HttpClient' , db_conn : 'Database' ): client . pust ( '/users/create/' , data =... ) user_data = db_conn . fetchrow ( 'select * from users' ) assert user_data == { 'id' : IsPositiveInt , # (1)! 'username' : 'samuelcolvin' , # (2)! 'avatar_file' : IsStr ( regex = r '/[a-z0-9\\-] {10} /example\\.png' ), # (3)! 'settings_json' : IsJson ({ 'theme' : 'dark' , 'language' : 'en' }), # (4)! 'created_ts' : IsNow ( delta = 3 ), # (5)! } We don't actually care what the id is, just that it's present, it's an int and it's positive. We can use a normal key and value here since we know exactly what value username should have before we test it. avatar_file is a string, but we don't know all of the string before the assert , just the format (regex) it should match. settings_json is a JSON string, but it's simpler and more robust to confirm it represents a particular python object rather than compare strings. created_at is a datetime , although we don't know (or care) about its exact value; since the user was just created we know it must be close to now. delta is optional, it defaults to 2 seconds. Without dirty-equals , you'd have to compare individual fields and/or modify some fields before comparison - the test would not be declarative or as clear. dirty-equals can do so much more than that, for example: IsPartialDict lets you compare a subset of a dictionary IsStrictDict lets you confirm order in a dictionary IsList and IsTuple lets you compare partial lists and tuples, with or without order constraints nesting any of these types inside any others IsInstance lets you simply confirm the type of an object You can even use boolean operators | and & to combine multiple conditions and much more...","title":"Usage"},{"location":"#installation","text":"Simply: pip install dirty-equals dirty-equals requires Python 3.7+ .","title":"Installation"},{"location":"internals/","text":"Internals \u00b6 How the magic of DirtyEquals.__eq__ works? \u00b6 When you call x == y , Python first calls x.__eq__(y) . This would not help us much, because we would have to keep an eye on order of the arguments when comparing to DirtyEquals objects. But that's where were another feature of Python comes in. When x.__eq__(y) returns the NotImplemented object, then Python will try to call y.__eq__(x) . Objects in the standard library return that value when they don't know how to compare themselves to objects of type(y) (Without checking the C source I can't be certain if this assumption holds for all classes, but it works for all the basic ones). In pathlib.PurePath you can see an example how that is implemented in Python. By default, object implements __eq__() by using is , returning NotImplemented in the case of a false comparison: True if x is y else NotImplemented . See the Python documentation for more information ( object.__eq__ ).","title":"Internals"},{"location":"internals/#internals","text":"","title":"Internals"},{"location":"internals/#how-the-magic-of-dirtyequals__eq__-works","text":"When you call x == y , Python first calls x.__eq__(y) . This would not help us much, because we would have to keep an eye on order of the arguments when comparing to DirtyEquals objects. But that's where were another feature of Python comes in. When x.__eq__(y) returns the NotImplemented object, then Python will try to call y.__eq__(x) . Objects in the standard library return that value when they don't know how to compare themselves to objects of type(y) (Without checking the C source I can't be certain if this assumption holds for all classes, but it works for all the basic ones). In pathlib.PurePath you can see an example how that is implemented in Python. By default, object implements __eq__() by using is , returning NotImplemented in the case of a false comparison: True if x is y else NotImplemented . See the Python documentation for more information ( object.__eq__ ).","title":"How the magic of DirtyEquals.__eq__ works?"},{"location":"usage/","text":"Boolean Logic \u00b6 dirty-equals types can be combined based on either & (and, all checks must be True for the combined check to be True ) or | (or, any check can be True for the combined check to be True ). Types can also be inverted using the ~ operator, this is equivalent to using != instead of == . Example: Boolean Combination of Types from dirty_equals import Contains , HasLen assert [ 'a' , 'b' , 'c' ] == HasLen ( 3 ) & Contains ( 'a' ) # (1)! assert [ 'a' , 'b' , 'c' ] == HasLen ( 3 ) | Contains ( 'z' ) # (2)! assert [ 'a' , 'b' , 'c' ] != Contains ( 'z' ) assert [ 'a' , 'b' , 'c' ] == ~ Contains ( 'z' ) The object on the left has to both have length 3 and contain \"a\" The object on the left has to either have length 3 or contain \"z\" Initialised vs. Class comparison \u00b6 Warning This does not work with PyPy. dirty-equals allows comparison with types regardless of whether they've been initialised. This saves users adding () in lots of places. Example: Initialised vs. Uninitialised from dirty_equals import IsInt # these two cases are the same assert 1 == IsInt assert 1 == IsInt () Note Types that require at least on argument when being initialised (like IsApprox ) cannot be used like this, comparisons will just return False . __repr__ and pytest compatibility \u00b6 dirty-equals types have reasonable __repr__ methods, which describe types and generally are a close match of how they would be created: __repr__ from dirty_equals import IsApprox , IsInt assert repr ( IsInt ) == 'IsInt' assert repr ( IsInt ()) == 'IsInt()' assert repr ( IsApprox ( 42 )) == 'IsApprox(approx=42)' However the repr method of types changes when an equals ( == ) operation on them returns a True , in this case the __repr__ method will return repr(other) . repr() after comparison from dirty_equals import IsInt v = IsInt () assert 42 == v assert repr ( v ) == '42' This black magic is designed to make the output of pytest when asserts on large objects fail as simple as possible to read. Consider the following unit test: pytest error example from datetime import datetime from dirty_equals import IsNow , IsPositiveInt def test_partial_dict (): api_response_data = { 'id' : 1 , # (1)! 'first_name' : 'John' , 'last_name' : 'Doe' , 'created_at' : datetime . now () . isoformat (), 'phone' : '+44 123456789' , } assert api_response_data == { 'id' : IsPositiveInt (), 'first_name' : 'John' , 'last_name' : 'Doe' , 'created_at' : IsNow ( iso_string = True ), # phone number is missing, so the test will fail } For simplicity we've hardcoded id here, but in a test it could be any positive int, hence why we need IsPositiveInt() Here's an except from the output of pytest -vv show the error details: pytest output E Common items: E {'created_at': '2022-02-25T15:41:38.493512', E 'first_name': 'John', E 'id': 1, E 'last_name': 'Doe'} E Left contains 1 more item: E {'phone': '+44 123456789'} E Full diff: E { E 'created_at': '2022-02-25T15:41:38.493512', E 'first_name': 'John', E 'id': 1, E 'last_name': 'Doe', E + 'phone': '+44 123456789', E } It's easy to see that the phone key is missing, id and created_at are represented by the exact values they were compared to, so don't show as different in the \"Full diff\" section. Warning This black magic only works when using initialised types, if IsPositiveInt was used instead IsPositiveInt() in the above example, the output would not be as clean.","title":"Usage"},{"location":"usage/#boolean-logic","text":"dirty-equals types can be combined based on either & (and, all checks must be True for the combined check to be True ) or | (or, any check can be True for the combined check to be True ). Types can also be inverted using the ~ operator, this is equivalent to using != instead of == . Example: Boolean Combination of Types from dirty_equals import Contains , HasLen assert [ 'a' , 'b' , 'c' ] == HasLen ( 3 ) & Contains ( 'a' ) # (1)! assert [ 'a' , 'b' , 'c' ] == HasLen ( 3 ) | Contains ( 'z' ) # (2)! assert [ 'a' , 'b' , 'c' ] != Contains ( 'z' ) assert [ 'a' , 'b' , 'c' ] == ~ Contains ( 'z' ) The object on the left has to both have length 3 and contain \"a\" The object on the left has to either have length 3 or contain \"z\"","title":"Boolean Logic"},{"location":"usage/#initialised-vs-class-comparison","text":"Warning This does not work with PyPy. dirty-equals allows comparison with types regardless of whether they've been initialised. This saves users adding () in lots of places. Example: Initialised vs. Uninitialised from dirty_equals import IsInt # these two cases are the same assert 1 == IsInt assert 1 == IsInt () Note Types that require at least on argument when being initialised (like IsApprox ) cannot be used like this, comparisons will just return False .","title":"Initialised vs. Class comparison"},{"location":"usage/#__repr__-and-pytest-compatibility","text":"dirty-equals types have reasonable __repr__ methods, which describe types and generally are a close match of how they would be created: __repr__ from dirty_equals import IsApprox , IsInt assert repr ( IsInt ) == 'IsInt' assert repr ( IsInt ()) == 'IsInt()' assert repr ( IsApprox ( 42 )) == 'IsApprox(approx=42)' However the repr method of types changes when an equals ( == ) operation on them returns a True , in this case the __repr__ method will return repr(other) . repr() after comparison from dirty_equals import IsInt v = IsInt () assert 42 == v assert repr ( v ) == '42' This black magic is designed to make the output of pytest when asserts on large objects fail as simple as possible to read. Consider the following unit test: pytest error example from datetime import datetime from dirty_equals import IsNow , IsPositiveInt def test_partial_dict (): api_response_data = { 'id' : 1 , # (1)! 'first_name' : 'John' , 'last_name' : 'Doe' , 'created_at' : datetime . now () . isoformat (), 'phone' : '+44 123456789' , } assert api_response_data == { 'id' : IsPositiveInt (), 'first_name' : 'John' , 'last_name' : 'Doe' , 'created_at' : IsNow ( iso_string = True ), # phone number is missing, so the test will fail } For simplicity we've hardcoded id here, but in a test it could be any positive int, hence why we need IsPositiveInt() Here's an except from the output of pytest -vv show the error details: pytest output E Common items: E {'created_at': '2022-02-25T15:41:38.493512', E 'first_name': 'John', E 'id': 1, E 'last_name': 'Doe'} E Left contains 1 more item: E {'phone': '+44 123456789'} E Full diff: E { E 'created_at': '2022-02-25T15:41:38.493512', E 'first_name': 'John', E 'id': 1, E 'last_name': 'Doe', E + 'phone': '+44 123456789', E } It's easy to see that the phone key is missing, id and created_at are represented by the exact values they were compared to, so don't show as different in the \"Full diff\" section. Warning This black magic only works when using initialised types, if IsPositiveInt was used instead IsPositiveInt() in the above example, the output would not be as clean.","title":"__repr__ and pytest compatibility"},{"location":"types/boolean/","text":"Boolean Types \u00b6 IsTrueLike \u00b6 Bases: DirtyEquals [ bool ] Check if the value is True like. IsTrueLike allows comparison to anything and effectively uses just return bool(other) . Example of basic usage: IsTrueLike from dirty_equals import IsTrueLike assert True == IsTrueLike assert 1 == IsTrueLike assert 'true' == IsTrueLike assert 'foobar' == IsTrueLike # any non-empty string is \"True\" assert '' != IsTrueLike assert [ 1 ] == IsTrueLike assert {} != IsTrueLike assert None != IsTrueLike IsFalseLike \u00b6 IsFalseLike ( * , allow_strings : bool = False ) Bases: DirtyEquals [ bool ] Check if the value is False like. IsFalseLike allows comparison to anything and effectively uses return not bool(other) (with string checks if allow_strings=True is set). Parameters: Name Type Description Default allow_strings bool if True , allow comparisons to False like strings, case-insensitive, allows '' , 'false' and any string where float(other) == 0 (e.g. '0' ). False Example of basic usage: IsFalseLike from dirty_equals import IsFalseLike assert False == IsFalseLike assert 0 == IsFalseLike assert 'false' == IsFalseLike ( allow_strings = True ) assert '0' == IsFalseLike ( allow_strings = True ) assert 'foobar' != IsFalseLike ( allow_strings = True ) assert 'false' != IsFalseLike assert 'True' != IsFalseLike ( allow_strings = True ) assert [ 1 ] != IsFalseLike assert {} == IsFalseLike assert None == IsFalseLike assert '' == IsFalseLike ( allow_strings = True ) assert '' == IsFalseLike","title":"Boolean Types"},{"location":"types/boolean/#boolean-types","text":"","title":"Boolean Types"},{"location":"types/boolean/#dirty_equals.IsTrueLike","text":"Bases: DirtyEquals [ bool ] Check if the value is True like. IsTrueLike allows comparison to anything and effectively uses just return bool(other) . Example of basic usage: IsTrueLike from dirty_equals import IsTrueLike assert True == IsTrueLike assert 1 == IsTrueLike assert 'true' == IsTrueLike assert 'foobar' == IsTrueLike # any non-empty string is \"True\" assert '' != IsTrueLike assert [ 1 ] == IsTrueLike assert {} != IsTrueLike assert None != IsTrueLike","title":"IsTrueLike"},{"location":"types/boolean/#dirty_equals.IsFalseLike","text":"IsFalseLike ( * , allow_strings : bool = False ) Bases: DirtyEquals [ bool ] Check if the value is False like. IsFalseLike allows comparison to anything and effectively uses return not bool(other) (with string checks if allow_strings=True is set). Parameters: Name Type Description Default allow_strings bool if True , allow comparisons to False like strings, case-insensitive, allows '' , 'false' and any string where float(other) == 0 (e.g. '0' ). False Example of basic usage: IsFalseLike from dirty_equals import IsFalseLike assert False == IsFalseLike assert 0 == IsFalseLike assert 'false' == IsFalseLike ( allow_strings = True ) assert '0' == IsFalseLike ( allow_strings = True ) assert 'foobar' != IsFalseLike ( allow_strings = True ) assert 'false' != IsFalseLike assert 'True' != IsFalseLike ( allow_strings = True ) assert [ 1 ] != IsFalseLike assert {} == IsFalseLike assert None == IsFalseLike assert '' == IsFalseLike ( allow_strings = True ) assert '' == IsFalseLike","title":"IsFalseLike"},{"location":"types/custom/","text":"Custom Types \u00b6 DirtyEquals \u00b6 Bases: Generic [ T ] Base type for all dirty-equals types. __init__ \u00b6 __init__ ( * repr_args : Any , ** repr_kwargs : Any ) Parameters: Name Type Description Default *repr_args Any unnamed args to be used in __repr__ () **repr_kwargs Any named args to be used in __repr__ {} equals \u00b6 equals ( other : Any ) -> bool Abstract method, must be implemented by subclasses. TypeError and ValueError are caught in __eq__ and indicate other is not equals to this type. value property \u00b6 value () -> T Property to get the value last successfully compared to this object. This is seldom very useful, put it's provided for completeness. Example of usage: .values from dirty_equals import IsStr token_is_str = IsStr ( regex = r 't-.+' ) assert 't-123' == token_is_str print ( token_is_str . value ) #> t-123 Custom Type Example \u00b6 To demonstrate the use of custom types, we'll create a custom type that matches any even number. We won't inherit from IsNumeric in this case to keep the example simple. IsEven from decimal import Decimal from typing import Any , Union from dirty_equals import DirtyEquals , IsOneOf class IsEven ( DirtyEquals [ Union [ int , float , Decimal ]]): def equals ( self , other : Any ) -> bool : return other % 2 == 0 assert 2 == IsEven assert 3 != IsEven assert 'foobar' != IsEven assert 3 == IsEven | IsOneOf ( 3 ) There are a few advantages of inheriting from DirtyEquals compared to just implementing your own class with an __eq__ method: TypeError and ValueError in equals are caught and result in a not-equals result. A useful __repr__ is generated, and modified if the == operation returns True , see pytest compatibility boolean logic works out of the box Uninitialised usage ( IsEven rather than IsEven() ) works out of the box","title":"Custom Types"},{"location":"types/custom/#custom-types","text":"","title":"Custom Types"},{"location":"types/custom/#dirty_equals._base.DirtyEquals","text":"Bases: Generic [ T ] Base type for all dirty-equals types.","title":"DirtyEquals"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.__init__","text":"__init__ ( * repr_args : Any , ** repr_kwargs : Any ) Parameters: Name Type Description Default *repr_args Any unnamed args to be used in __repr__ () **repr_kwargs Any named args to be used in __repr__ {}","title":"__init__()"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.equals","text":"equals ( other : Any ) -> bool Abstract method, must be implemented by subclasses. TypeError and ValueError are caught in __eq__ and indicate other is not equals to this type.","title":"equals()"},{"location":"types/custom/#dirty_equals._base.DirtyEquals.value","text":"value () -> T Property to get the value last successfully compared to this object. This is seldom very useful, put it's provided for completeness. Example of usage: .values from dirty_equals import IsStr token_is_str = IsStr ( regex = r 't-.+' ) assert 't-123' == token_is_str print ( token_is_str . value ) #> t-123","title":"value()"},{"location":"types/custom/#custom-type-example","text":"To demonstrate the use of custom types, we'll create a custom type that matches any even number. We won't inherit from IsNumeric in this case to keep the example simple. IsEven from decimal import Decimal from typing import Any , Union from dirty_equals import DirtyEquals , IsOneOf class IsEven ( DirtyEquals [ Union [ int , float , Decimal ]]): def equals ( self , other : Any ) -> bool : return other % 2 == 0 assert 2 == IsEven assert 3 != IsEven assert 'foobar' != IsEven assert 3 == IsEven | IsOneOf ( 3 ) There are a few advantages of inheriting from DirtyEquals compared to just implementing your own class with an __eq__ method: TypeError and ValueError in equals are caught and result in a not-equals result. A useful __repr__ is generated, and modified if the == operation returns True , see pytest compatibility boolean logic works out of the box Uninitialised usage ( IsEven rather than IsEven() ) works out of the box","title":"Custom Type Example"},{"location":"types/datetime/","text":"Date and Time Types \u00b6 IsDatetime \u00b6 IsDatetime ( * , approx : Optional [ datetime ] = None , delta : Optional [ Union [ timedelta , int , float ]] = None , gt : Optional [ datetime ] = None , lt : Optional [ datetime ] = None , ge : Optional [ datetime ] = None , le : Optional [ datetime ] = None , unix_number : bool = False , iso_string : bool = False , format_string : Optional [ str ] = None , enforce_tz : bool = True ) Bases: IsNumeric [ datetime ] Check if the value is a datetime, and matches the given conditions. Parameters: Name Type Description Default approx Optional [ datetime ] A value to approximately compare to. None delta Optional [ Union [ timedelta , int , float ]] The allowable different when comparing to the value to approx , if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. None gt Optional [ datetime ] Value which the compared value should be greater than (after). None lt Optional [ datetime ] Value which the compared value should be less than (before). None ge Optional [ datetime ] Value which the compared value should be greater than (after) or equal to. None le Optional [ datetime ] Value which the compared value should be less than (before) or equal to. None unix_number bool whether to allow unix timestamp numbers in comparison False iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None enforce_tz bool whether timezone should be enforced in comparison, see below for more details True Examples of basic usage: IsDatetime from datetime import datetime from dirty_equals import IsDatetime y2k = datetime ( 2000 , 1 , 1 ) assert datetime ( 2000 , 1 , 1 ) == IsDatetime ( approx = y2k ) # Note: this requires the system timezone to be UTC assert 946684800.123 == IsDatetime ( approx = y2k , unix_number = True ) assert datetime ( 2000 , 1 , 1 , 0 , 0 , 9 ) == IsDatetime ( approx = y2k , delta = 10 ) assert '2000-01-01T00:00' == IsDatetime ( approx = y2k , iso_string = True ) assert datetime ( 2000 , 1 , 2 ) == IsDatetime ( gt = y2k ) assert datetime ( 1999 , 1 , 2 ) != IsDatetime ( gt = y2k ) Timezones \u00b6 Timezones are hard, anyone who claims otherwise is either a genius, a liar, or an idiot. IsDatetime and its subtypes (e.g. IsNow ) can be used in two modes, based on the enforce_tz parameter: enforce_tz=True (the default): if the datetime wrapped by IsDatetime is timezone naive, the compared value must also be timezone naive. if the datetime wrapped by IsDatetime has a timezone, the compared value must have a timezone with the same offset. enforce_tz=False : if the datetime wrapped by IsDatetime is timezone naive, the compared value can either be naive or have a timezone all that matters is the datetime values match. if the datetime wrapped by IsDatetime has a timezone, the compared value needs to represent the same point in time - either way it must have a timezone. Example IsDatetime & timezones from datetime import datetime import pytz from dirty_equals import IsDatetime tz_london = pytz . timezone ( 'Europe/London' ) new_year_london = tz_london . localize ( datetime ( 2000 , 1 , 1 )) tz_nyc = pytz . timezone ( 'America/New_York' ) new_year_eve_nyc = tz_nyc . localize ( datetime ( 1999 , 12 , 31 , 19 , 0 , 0 )) assert new_year_eve_nyc == IsDatetime ( approx = new_year_london , enforce_tz = False ) assert new_year_eve_nyc != IsDatetime ( approx = new_year_london , enforce_tz = True ) new_year_naive = datetime ( 2000 , 1 , 1 ) assert new_year_naive != IsDatetime ( approx = new_year_london , enforce_tz = False ) assert new_year_naive != IsDatetime ( approx = new_year_eve_nyc , enforce_tz = False ) assert new_year_london == IsDatetime ( approx = new_year_naive , enforce_tz = False ) assert new_year_eve_nyc != IsDatetime ( approx = new_year_naive , enforce_tz = False ) IsNow \u00b6 IsNow ( * , delta : Union [ timedelta , int , float ] = 2 , unix_number : bool = False , iso_string : bool = False , format_string : Optional [ str ] = None , enforce_tz : bool = True , tz : Union [ None , str , tzinfo ] = None ) Bases: IsDatetime Check if a datetime is close to now, this is similar to IsDatetime(approx=datetime.now()) , but slightly more powerful. Parameters: Name Type Description Default delta Union [ timedelta , int , float ] The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. 2 unix_number bool whether to allow unix timestamp numbers in comparison False iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None enforce_tz bool whether timezone should be enforced in comparison, see below for more details True tz Union [None, str , tzinfo ] either a pytz.timezone , a datetime.timezone or a string which will be passed to pytz.timezone , if provided now will be converted to this timezone. None IsNow from datetime import datetime , timezone from dirty_equals import IsNow now = datetime . now () assert now == IsNow assert now . timestamp () == IsNow ( unix_number = True ) assert now . timestamp () != IsNow assert now . isoformat () == IsNow ( iso_string = True ) assert now . isoformat () != IsNow utc_now = datetime . utcnow () . replace ( tzinfo = timezone . utc ) assert utc_now == IsNow ( tz = timezone . utc ) IsDate \u00b6 IsDate ( * , approx : Optional [ date ] = None , delta : Optional [ Union [ timedelta , int , float ]] = None , gt : Optional [ date ] = None , lt : Optional [ date ] = None , ge : Optional [ date ] = None , le : Optional [ date ] = None , iso_string : bool = False , format_string : Optional [ str ] = None ) Bases: IsNumeric [ date ] Check if the value is a date, and matches the given conditions. Parameters: Name Type Description Default approx Optional [ date ] A value to approximately compare to. None delta Optional [ Union [ timedelta , int , float ]] The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. None gt Optional [ date ] Value which the compared value should be greater than (after). None lt Optional [ date ] Value which the compared value should be less than (before). None ge Optional [ date ] Value which the compared value should be greater than (after) or equal to. None le Optional [ date ] Value which the compared value should be less than (before) or equal to. None iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None Examples of basic usage: IsDate from datetime import date from dirty_equals import IsDate y2k = date ( 2000 , 1 , 1 ) assert date ( 2000 , 1 , 1 ) == IsDate ( approx = y2k ) assert '2000-01-01' == IsDate ( approx = y2k , iso_string = True ) assert date ( 2000 , 1 , 2 ) == IsDate ( gt = y2k ) assert date ( 1999 , 1 , 2 ) != IsDate ( gt = y2k ) IsToday \u00b6 IsToday ( * , iso_string : bool = False , format_string : Optional [ str ] = None ) Bases: IsDate Check if a date is today, this is similar to IsDate(approx=date.today()) , but slightly more powerful. Parameters: Name Type Description Default iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None IsToday from datetime import date , timedelta from dirty_equals import IsToday today = date . today () assert today == IsToday assert today . isoformat () == IsToday ( iso_string = True ) assert today . isoformat () != IsToday assert today + timedelta ( days = 1 ) != IsToday assert today . strftime ( '%Y/%m/ %d ' ) == IsToday ( format_string = '%Y/%m/ %d ' ) assert today . strftime ( '%Y/%m/ %d ' ) != IsToday ()","title":"Date and Time Types"},{"location":"types/datetime/#date-and-time-types","text":"","title":"Date and Time Types"},{"location":"types/datetime/#dirty_equals.IsDatetime","text":"IsDatetime ( * , approx : Optional [ datetime ] = None , delta : Optional [ Union [ timedelta , int , float ]] = None , gt : Optional [ datetime ] = None , lt : Optional [ datetime ] = None , ge : Optional [ datetime ] = None , le : Optional [ datetime ] = None , unix_number : bool = False , iso_string : bool = False , format_string : Optional [ str ] = None , enforce_tz : bool = True ) Bases: IsNumeric [ datetime ] Check if the value is a datetime, and matches the given conditions. Parameters: Name Type Description Default approx Optional [ datetime ] A value to approximately compare to. None delta Optional [ Union [ timedelta , int , float ]] The allowable different when comparing to the value to approx , if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. None gt Optional [ datetime ] Value which the compared value should be greater than (after). None lt Optional [ datetime ] Value which the compared value should be less than (before). None ge Optional [ datetime ] Value which the compared value should be greater than (after) or equal to. None le Optional [ datetime ] Value which the compared value should be less than (before) or equal to. None unix_number bool whether to allow unix timestamp numbers in comparison False iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None enforce_tz bool whether timezone should be enforced in comparison, see below for more details True Examples of basic usage: IsDatetime from datetime import datetime from dirty_equals import IsDatetime y2k = datetime ( 2000 , 1 , 1 ) assert datetime ( 2000 , 1 , 1 ) == IsDatetime ( approx = y2k ) # Note: this requires the system timezone to be UTC assert 946684800.123 == IsDatetime ( approx = y2k , unix_number = True ) assert datetime ( 2000 , 1 , 1 , 0 , 0 , 9 ) == IsDatetime ( approx = y2k , delta = 10 ) assert '2000-01-01T00:00' == IsDatetime ( approx = y2k , iso_string = True ) assert datetime ( 2000 , 1 , 2 ) == IsDatetime ( gt = y2k ) assert datetime ( 1999 , 1 , 2 ) != IsDatetime ( gt = y2k )","title":"IsDatetime"},{"location":"types/datetime/#timezones","text":"Timezones are hard, anyone who claims otherwise is either a genius, a liar, or an idiot. IsDatetime and its subtypes (e.g. IsNow ) can be used in two modes, based on the enforce_tz parameter: enforce_tz=True (the default): if the datetime wrapped by IsDatetime is timezone naive, the compared value must also be timezone naive. if the datetime wrapped by IsDatetime has a timezone, the compared value must have a timezone with the same offset. enforce_tz=False : if the datetime wrapped by IsDatetime is timezone naive, the compared value can either be naive or have a timezone all that matters is the datetime values match. if the datetime wrapped by IsDatetime has a timezone, the compared value needs to represent the same point in time - either way it must have a timezone. Example IsDatetime & timezones from datetime import datetime import pytz from dirty_equals import IsDatetime tz_london = pytz . timezone ( 'Europe/London' ) new_year_london = tz_london . localize ( datetime ( 2000 , 1 , 1 )) tz_nyc = pytz . timezone ( 'America/New_York' ) new_year_eve_nyc = tz_nyc . localize ( datetime ( 1999 , 12 , 31 , 19 , 0 , 0 )) assert new_year_eve_nyc == IsDatetime ( approx = new_year_london , enforce_tz = False ) assert new_year_eve_nyc != IsDatetime ( approx = new_year_london , enforce_tz = True ) new_year_naive = datetime ( 2000 , 1 , 1 ) assert new_year_naive != IsDatetime ( approx = new_year_london , enforce_tz = False ) assert new_year_naive != IsDatetime ( approx = new_year_eve_nyc , enforce_tz = False ) assert new_year_london == IsDatetime ( approx = new_year_naive , enforce_tz = False ) assert new_year_eve_nyc != IsDatetime ( approx = new_year_naive , enforce_tz = False )","title":"Timezones"},{"location":"types/datetime/#dirty_equals.IsNow","text":"IsNow ( * , delta : Union [ timedelta , int , float ] = 2 , unix_number : bool = False , iso_string : bool = False , format_string : Optional [ str ] = None , enforce_tz : bool = True , tz : Union [ None , str , tzinfo ] = None ) Bases: IsDatetime Check if a datetime is close to now, this is similar to IsDatetime(approx=datetime.now()) , but slightly more powerful. Parameters: Name Type Description Default delta Union [ timedelta , int , float ] The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. 2 unix_number bool whether to allow unix timestamp numbers in comparison False iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None enforce_tz bool whether timezone should be enforced in comparison, see below for more details True tz Union [None, str , tzinfo ] either a pytz.timezone , a datetime.timezone or a string which will be passed to pytz.timezone , if provided now will be converted to this timezone. None IsNow from datetime import datetime , timezone from dirty_equals import IsNow now = datetime . now () assert now == IsNow assert now . timestamp () == IsNow ( unix_number = True ) assert now . timestamp () != IsNow assert now . isoformat () == IsNow ( iso_string = True ) assert now . isoformat () != IsNow utc_now = datetime . utcnow () . replace ( tzinfo = timezone . utc ) assert utc_now == IsNow ( tz = timezone . utc )","title":"IsNow"},{"location":"types/datetime/#dirty_equals.IsDate","text":"IsDate ( * , approx : Optional [ date ] = None , delta : Optional [ Union [ timedelta , int , float ]] = None , gt : Optional [ date ] = None , lt : Optional [ date ] = None , ge : Optional [ date ] = None , le : Optional [ date ] = None , iso_string : bool = False , format_string : Optional [ str ] = None ) Bases: IsNumeric [ date ] Check if the value is a date, and matches the given conditions. Parameters: Name Type Description Default approx Optional [ date ] A value to approximately compare to. None delta Optional [ Union [ timedelta , int , float ]] The allowable different when comparing to the value to now, if omitted 2 seconds is used, ints and floats are assumed to represent seconds and converted to timedelta s. None gt Optional [ date ] Value which the compared value should be greater than (after). None lt Optional [ date ] Value which the compared value should be less than (before). None ge Optional [ date ] Value which the compared value should be greater than (after) or equal to. None le Optional [ date ] Value which the compared value should be less than (before) or equal to. None iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None Examples of basic usage: IsDate from datetime import date from dirty_equals import IsDate y2k = date ( 2000 , 1 , 1 ) assert date ( 2000 , 1 , 1 ) == IsDate ( approx = y2k ) assert '2000-01-01' == IsDate ( approx = y2k , iso_string = True ) assert date ( 2000 , 1 , 2 ) == IsDate ( gt = y2k ) assert date ( 1999 , 1 , 2 ) != IsDate ( gt = y2k )","title":"IsDate"},{"location":"types/datetime/#dirty_equals.IsToday","text":"IsToday ( * , iso_string : bool = False , format_string : Optional [ str ] = None ) Bases: IsDate Check if a date is today, this is similar to IsDate(approx=date.today()) , but slightly more powerful. Parameters: Name Type Description Default iso_string bool whether to allow iso formatted strings in comparison False format_string Optional [ str ] if provided, format_string is used with datetime.strptime to parse strings None IsToday from datetime import date , timedelta from dirty_equals import IsToday today = date . today () assert today == IsToday assert today . isoformat () == IsToday ( iso_string = True ) assert today . isoformat () != IsToday assert today + timedelta ( days = 1 ) != IsToday assert today . strftime ( '%Y/%m/ %d ' ) == IsToday ( format_string = '%Y/%m/ %d ' ) assert today . strftime ( '%Y/%m/ %d ' ) != IsToday ()","title":"IsToday"},{"location":"types/dict/","text":"Dictionary Types \u00b6 IsDict \u00b6 IsDict ( * expected_args : dict [ Any , Any ], ** expected_kwargs : Any ) Bases: DirtyEquals [ Dict [ Any , Any ]] Base class for comparing dictionaries. By default, IsDict isn't particularly useful on its own (it behaves pretty much like a normal dict ), but it can be subclassed (see IsPartialDict and IsStrictDict ) or modified with .settings(...) to powerful things. Can be created from either keyword arguments or an existing dictionary (same as dict() ). IsDict is not particularly useful on its own, but it can be subclassed or modified with .settings(...) to facilitate powerful comparison of dictionaries. IsDict from dirty_equals import IsDict assert { 'a' : 1 , 'b' : 2 } == IsDict ( a = 1 , b = 2 ) assert { 1 : 2 , 3 : 4 } == IsDict ({ 1 : 2 , 3 : 4 }) settings \u00b6 settings ( * , strict : bool | None = None , partial : bool | None = None , ignore : None | Container [ Any ] | Callable [[ Any ], bool ] = NotGiven ) -> IsDict Allows you to customise the behaviour of IsDict , technically a new IsDict is required to allow chaining. Parameters: Name Type Description Default strict bool If True , the order of key/value pairs must match. None partial bool If True , only keys include in the wrapped dict are checked. None ignore Union [None, Container [ Any ], Callable [[ Any ], bool ]] Values to omit from comparison. Can be either a Container (e.g. set or list ) of values to ignore, or a function that takes a value and should return True if the value should be ignored. NotGiven IsDict.settings(...) from dirty_equals import IsDict assert { 'a' : 1 , 'b' : 2 , 'c' : None } != IsDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : None } == IsDict ( a = 1 , b = 2 ) . settings ( partial = True ) # (1)! assert { 'b' : 2 , 'a' : 1 } == IsDict ( a = 1 , b = 2 ) assert { 'b' : 2 , 'a' : 1 } != IsDict ( a = 1 , b = 2 ) . settings ( strict = True ) # (2)! # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsDict ( a = 1 , c = 3 ) . settings ( strict = True , partial = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsDict ( a = 1 , c = 3 ) . settings ( strict = True , partial = True ) This is the same as IsPartialDict(a=1, b=2) This is the same as IsStrictDict(a=1, b=2) IsPartialDict \u00b6 Bases: IsDict Partial dictionary comparison, this is the same as IsDict(...).settings(partial=True) . IsPartialDict from dirty_equals import IsPartialDict assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } == IsPartialDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } != IsPartialDict ( a = 1 , b = 3 ) assert { 'a' : 1 , 'b' : 2 , 'd' : 3 } != IsPartialDict ( a = 1 , b = 2 , c = 3 ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsPartialDict ( a = 1 , c = 3 ) . settings ( strict = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsPartialDict ( a = 1 , c = 3 ) . settings ( strict = True ) IsIgnoreDict \u00b6 Bases: IsDict Dictionary comparison with None values ignored, this is the same as IsDict(...).settings(ignore={None}) . .settings(...) can be used to customise the behaviour of IsIgnoreDict , in particular changing which values are ignored. IsIgnoreDict from dirty_equals import IsIgnoreDict assert { 'a' : 1 , 'b' : 2 , 'c' : None } == IsIgnoreDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 'ignore' } == ( IsIgnoreDict ( a = 1 , b = 2 ) . settings ( ignore = { None , 'ignore' }) ) def is_even ( v : int ) -> bool : return v % 2 == 0 assert { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : 4 } == ( IsIgnoreDict ( a = 1 , c = 3 ) . settings ( ignore = is_even ) ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsIgnoreDict ( a = 1 , c = 3 ) . settings ( strict = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsIgnoreDict ( a = 1 , c = 3 ) . settings ( strict = True ) IsStrictDict \u00b6 Bases: IsDict Dictionary comparison with order enforced, this is the same as IsDict(...).settings(strict=True) . IsDict.settings(...) from dirty_equals import IsStrictDict assert { 'a' : 1 , 'b' : 2 } == IsStrictDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } != IsStrictDict ( a = 1 , b = 2 ) assert { 'b' : 2 , 'a' : 1 } != IsStrictDict ( a = 1 , b = 2 ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsStrictDict ( a = 1 , c = 3 ) . settings ( partial = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsStrictDict ( a = 1 , c = 3 ) . settings ( partial = True )","title":"Dictionary Types"},{"location":"types/dict/#dictionary-types","text":"","title":"Dictionary Types"},{"location":"types/dict/#dirty_equals.IsDict","text":"IsDict ( * expected_args : dict [ Any , Any ], ** expected_kwargs : Any ) Bases: DirtyEquals [ Dict [ Any , Any ]] Base class for comparing dictionaries. By default, IsDict isn't particularly useful on its own (it behaves pretty much like a normal dict ), but it can be subclassed (see IsPartialDict and IsStrictDict ) or modified with .settings(...) to powerful things. Can be created from either keyword arguments or an existing dictionary (same as dict() ). IsDict is not particularly useful on its own, but it can be subclassed or modified with .settings(...) to facilitate powerful comparison of dictionaries. IsDict from dirty_equals import IsDict assert { 'a' : 1 , 'b' : 2 } == IsDict ( a = 1 , b = 2 ) assert { 1 : 2 , 3 : 4 } == IsDict ({ 1 : 2 , 3 : 4 })","title":"IsDict"},{"location":"types/dict/#dirty_equals._dict.IsDict.settings","text":"settings ( * , strict : bool | None = None , partial : bool | None = None , ignore : None | Container [ Any ] | Callable [[ Any ], bool ] = NotGiven ) -> IsDict Allows you to customise the behaviour of IsDict , technically a new IsDict is required to allow chaining. Parameters: Name Type Description Default strict bool If True , the order of key/value pairs must match. None partial bool If True , only keys include in the wrapped dict are checked. None ignore Union [None, Container [ Any ], Callable [[ Any ], bool ]] Values to omit from comparison. Can be either a Container (e.g. set or list ) of values to ignore, or a function that takes a value and should return True if the value should be ignored. NotGiven IsDict.settings(...) from dirty_equals import IsDict assert { 'a' : 1 , 'b' : 2 , 'c' : None } != IsDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : None } == IsDict ( a = 1 , b = 2 ) . settings ( partial = True ) # (1)! assert { 'b' : 2 , 'a' : 1 } == IsDict ( a = 1 , b = 2 ) assert { 'b' : 2 , 'a' : 1 } != IsDict ( a = 1 , b = 2 ) . settings ( strict = True ) # (2)! # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsDict ( a = 1 , c = 3 ) . settings ( strict = True , partial = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsDict ( a = 1 , c = 3 ) . settings ( strict = True , partial = True ) This is the same as IsPartialDict(a=1, b=2) This is the same as IsStrictDict(a=1, b=2)","title":"settings()"},{"location":"types/dict/#dirty_equals.IsPartialDict","text":"Bases: IsDict Partial dictionary comparison, this is the same as IsDict(...).settings(partial=True) . IsPartialDict from dirty_equals import IsPartialDict assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } == IsPartialDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } != IsPartialDict ( a = 1 , b = 3 ) assert { 'a' : 1 , 'b' : 2 , 'd' : 3 } != IsPartialDict ( a = 1 , b = 2 , c = 3 ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsPartialDict ( a = 1 , c = 3 ) . settings ( strict = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsPartialDict ( a = 1 , c = 3 ) . settings ( strict = True )","title":"IsPartialDict"},{"location":"types/dict/#dirty_equals.IsIgnoreDict","text":"Bases: IsDict Dictionary comparison with None values ignored, this is the same as IsDict(...).settings(ignore={None}) . .settings(...) can be used to customise the behaviour of IsIgnoreDict , in particular changing which values are ignored. IsIgnoreDict from dirty_equals import IsIgnoreDict assert { 'a' : 1 , 'b' : 2 , 'c' : None } == IsIgnoreDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 'ignore' } == ( IsIgnoreDict ( a = 1 , b = 2 ) . settings ( ignore = { None , 'ignore' }) ) def is_even ( v : int ) -> bool : return v % 2 == 0 assert { 'a' : 1 , 'b' : 2 , 'c' : 3 , 'd' : 4 } == ( IsIgnoreDict ( a = 1 , c = 3 ) . settings ( ignore = is_even ) ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsIgnoreDict ( a = 1 , c = 3 ) . settings ( strict = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsIgnoreDict ( a = 1 , c = 3 ) . settings ( strict = True )","title":"IsIgnoreDict"},{"location":"types/dict/#dirty_equals.IsStrictDict","text":"Bases: IsDict Dictionary comparison with order enforced, this is the same as IsDict(...).settings(strict=True) . IsDict.settings(...) from dirty_equals import IsStrictDict assert { 'a' : 1 , 'b' : 2 } == IsStrictDict ( a = 1 , b = 2 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } != IsStrictDict ( a = 1 , b = 2 ) assert { 'b' : 2 , 'a' : 1 } != IsStrictDict ( a = 1 , b = 2 ) # combining partial and strict assert { 'a' : 1 , 'b' : None , 'c' : 3 } == IsStrictDict ( a = 1 , c = 3 ) . settings ( partial = True ) assert { 'b' : None , 'c' : 3 , 'a' : 1 } != IsStrictDict ( a = 1 , c = 3 ) . settings ( partial = True )","title":"IsStrictDict"},{"location":"types/inspection/","text":"Type Inspection \u00b6 IsInstance \u00b6 IsInstance ( expected_type : ExpectedType , * , only_direct_instance : bool = False ) Bases: DirtyEquals [ ExpectedType ] A type which checks that the value is an instance of the expected type. Parameters: Name Type Description Default expected_type ExpectedType The type to check against. required only_direct_instance bool whether instances of subclasses of expected_type should be considered equal. False Note IsInstance can be parameterized or initialised with a type - IsInstance[Foo] is exactly equivalent to IsInstance(Foo) . This allows usage to be analogous to type hints. Example: IsInstance from dirty_equals import IsInstance class Foo : pass class Bar ( Foo ): pass assert Foo () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo ) assert Foo != IsInstance [ Bar ] assert Bar () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo , only_direct_instance = True ) assert Bar () != IsInstance ( Foo , only_direct_instance = True ) HasName \u00b6 HasName ( expected_name : Union [ IsStr , str ], * , allow_instances : bool = True ) Bases: DirtyEquals [ T ] A type which checks that the value has the given __name__ attribute. Parameters: Name Type Description Default expected_name Union [ IsStr , str ] The name to check against. required allow_instances bool whether instances of classes with the given name should be considered equal, (e.g. whether other.__class__.__name__ == expected_name should be checked). True Example: HasName from dirty_equals import HasName , IsStr class Foo : pass assert Foo == HasName ( 'Foo' ) assert Foo == HasName [ 'Foo' ] assert Foo () == HasName ( 'Foo' ) assert Foo () != HasName ( 'Foo' , allow_instances = False ) assert Foo == HasName ( IsStr ( regex = 'F..' )) assert Foo != HasName ( 'Bar' ) assert int == HasName ( 'int' ) assert int == HasName ( 'int' ) HasRepr \u00b6 HasRepr ( expected_repr : Union [ IsStr , str ]) Bases: DirtyEquals [ T ] A type which checks that the value has the given repr() value. Parameters: Name Type Description Default expected_repr Union [ IsStr , str ] The expected repr value. required Example: HasRepr from dirty_equals import HasRepr , IsStr class Foo : def __repr__ ( self ): return 'This is a Foo' assert Foo () == HasRepr ( 'This is a Foo' ) assert Foo () == HasRepr [ 'This is a Foo' ] assert Foo == HasRepr ( IsStr ( regex = '<class.+' )) assert 42 == HasRepr ( '42' ) assert 43 != HasRepr ( '42' ) HasAttributes \u00b6 HasAttributes ( * expected_args : Dict [ Any , Any ], ** expected_kwargs : Any ) Bases: DirtyEquals [ Any ] A type which checks that the value has the given attributes. This is a partial check - e.g. the attributes provided to check do not need to be exhaustive. Can be created from either keyword arguments or an existing dictionary (same as dict() ). Example: HasAttributes from dirty_equals import AnyThing , HasAttributes , IsInt , IsStr class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def spam ( self ): pass assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 , b = 2 ) assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 ) assert Foo ( 1 , 's' ) == HasAttributes ( a = IsInt , b = IsStr ) assert Foo ( 1 , 2 ) != HasAttributes ( a = IsInt , b = IsStr ) assert Foo ( 1 , 2 ) != HasAttributes ( a = 1 , b = 2 , c = 3 ) assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 , b = 2 , spam = AnyThing )","title":"Type Inspection"},{"location":"types/inspection/#type-inspection","text":"","title":"Type Inspection"},{"location":"types/inspection/#dirty_equals.IsInstance","text":"IsInstance ( expected_type : ExpectedType , * , only_direct_instance : bool = False ) Bases: DirtyEquals [ ExpectedType ] A type which checks that the value is an instance of the expected type. Parameters: Name Type Description Default expected_type ExpectedType The type to check against. required only_direct_instance bool whether instances of subclasses of expected_type should be considered equal. False Note IsInstance can be parameterized or initialised with a type - IsInstance[Foo] is exactly equivalent to IsInstance(Foo) . This allows usage to be analogous to type hints. Example: IsInstance from dirty_equals import IsInstance class Foo : pass class Bar ( Foo ): pass assert Foo () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo ) assert Foo != IsInstance [ Bar ] assert Bar () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo , only_direct_instance = True ) assert Bar () != IsInstance ( Foo , only_direct_instance = True )","title":"IsInstance"},{"location":"types/inspection/#dirty_equals.HasName","text":"HasName ( expected_name : Union [ IsStr , str ], * , allow_instances : bool = True ) Bases: DirtyEquals [ T ] A type which checks that the value has the given __name__ attribute. Parameters: Name Type Description Default expected_name Union [ IsStr , str ] The name to check against. required allow_instances bool whether instances of classes with the given name should be considered equal, (e.g. whether other.__class__.__name__ == expected_name should be checked). True Example: HasName from dirty_equals import HasName , IsStr class Foo : pass assert Foo == HasName ( 'Foo' ) assert Foo == HasName [ 'Foo' ] assert Foo () == HasName ( 'Foo' ) assert Foo () != HasName ( 'Foo' , allow_instances = False ) assert Foo == HasName ( IsStr ( regex = 'F..' )) assert Foo != HasName ( 'Bar' ) assert int == HasName ( 'int' ) assert int == HasName ( 'int' )","title":"HasName"},{"location":"types/inspection/#dirty_equals.HasRepr","text":"HasRepr ( expected_repr : Union [ IsStr , str ]) Bases: DirtyEquals [ T ] A type which checks that the value has the given repr() value. Parameters: Name Type Description Default expected_repr Union [ IsStr , str ] The expected repr value. required Example: HasRepr from dirty_equals import HasRepr , IsStr class Foo : def __repr__ ( self ): return 'This is a Foo' assert Foo () == HasRepr ( 'This is a Foo' ) assert Foo () == HasRepr [ 'This is a Foo' ] assert Foo == HasRepr ( IsStr ( regex = '<class.+' )) assert 42 == HasRepr ( '42' ) assert 43 != HasRepr ( '42' )","title":"HasRepr"},{"location":"types/inspection/#dirty_equals.HasAttributes","text":"HasAttributes ( * expected_args : Dict [ Any , Any ], ** expected_kwargs : Any ) Bases: DirtyEquals [ Any ] A type which checks that the value has the given attributes. This is a partial check - e.g. the attributes provided to check do not need to be exhaustive. Can be created from either keyword arguments or an existing dictionary (same as dict() ). Example: HasAttributes from dirty_equals import AnyThing , HasAttributes , IsInt , IsStr class Foo : def __init__ ( self , a , b ): self . a = a self . b = b def spam ( self ): pass assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 , b = 2 ) assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 ) assert Foo ( 1 , 's' ) == HasAttributes ( a = IsInt , b = IsStr ) assert Foo ( 1 , 2 ) != HasAttributes ( a = IsInt , b = IsStr ) assert Foo ( 1 , 2 ) != HasAttributes ( a = 1 , b = 2 , c = 3 ) assert Foo ( 1 , 2 ) == HasAttributes ( a = 1 , b = 2 , spam = AnyThing )","title":"HasAttributes"},{"location":"types/numeric/","text":"Numeric Types \u00b6 IsInt \u00b6 Bases: IsNumeric [ int ] Checks that a value is an integer. Inherits from IsNumeric and can therefore be initialised with any of its arguments. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt assert 1 == IsInt ( exactly = 1 ) assert - 2 != IsInt ( exactly = 1 ) allowed_types = int class-attribute \u00b6 As the name suggests, only integers are allowed, booleans ( True are False ) are explicitly excluded although technically they are sub-types of int . IsFloat \u00b6 Bases: IsNumeric [ float ] Checks that a value is a float. Inherits from IsNumeric and can therefore be initialised with any of its arguments. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat assert 1.0 == IsFloat ( exactly = 1.0 ) assert 1.001 != IsFloat ( exactly = 1.0 ) allowed_types = float class-attribute \u00b6 As the name suggests, only floats are allowed. IsPositive \u00b6 Bases: IsNumber Check that a value is positive ( > 0 ), can be an int , a float or a Decimal (or indeed any value which implements __gt__ for 0 ). IsPositive from decimal import Decimal from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert Decimal ( '3.14' ) == IsPositive assert 0 != IsPositive assert - 1 != IsPositive IsNegative \u00b6 Bases: IsNumber Check that a value is negative ( < 0 ), can be an int , a float or a Decimal (or indeed any value which implements __lt__ for 0 ). IsNegative from decimal import Decimal from dirty_equals import IsNegative assert - 1.0 == IsNegative assert - 1 == IsNegative assert Decimal ( '-3.14' ) == IsNegative assert 0 != IsNegative assert 1 != IsNegative IsNonNegative \u00b6 Bases: IsNumber Check that a value is positive or zero ( >= 0 ), can be an int , a float or a Decimal (or indeed any value which implements __ge__ for 0 ). IsNonNegative from decimal import Decimal from dirty_equals import IsNonNegative assert 1.0 == IsNonNegative assert 1 == IsNonNegative assert Decimal ( '3.14' ) == IsNonNegative assert 0 == IsNonNegative assert - 1 != IsNonNegative assert Decimal ( '0' ) == IsNonNegative IsNonPositive \u00b6 Bases: IsNumber Check that a value is negative or zero ( <=0 ), can be an int , a float or a Decimal (or indeed any value which implements __le__ for 0 ). IsNonPositive from decimal import Decimal from dirty_equals import IsNonPositive assert - 1.0 == IsNonPositive assert - 1 == IsNonPositive assert Decimal ( '-3.14' ) == IsNonPositive assert 0 == IsNonPositive assert 1 != IsNonPositive assert Decimal ( '-0' ) == IsNonPositive assert Decimal ( '0' ) == IsNonPositive IsPositiveInt \u00b6 Bases: IsInt Like IsPositive but only for int s. IsPositiveInt from decimal import Decimal from dirty_equals import IsPositiveInt assert 1 == IsPositiveInt assert 1.0 != IsPositiveInt assert Decimal ( '3.14' ) != IsPositiveInt assert 0 != IsPositiveInt assert - 1 != IsPositiveInt IsNegativeInt \u00b6 Bases: IsInt Like IsNegative but only for int s. IsNegativeInt from decimal import Decimal from dirty_equals import IsNegativeInt assert - 1 == IsNegativeInt assert - 1.0 != IsNegativeInt assert Decimal ( '-3.14' ) != IsNegativeInt assert 0 != IsNegativeInt assert 1 != IsNegativeInt IsPositiveFloat \u00b6 Bases: IsFloat Like IsPositive but only for float s. IsPositiveFloat from decimal import Decimal from dirty_equals import IsPositiveFloat assert 1.0 == IsPositiveFloat assert 1 != IsPositiveFloat assert Decimal ( '3.14' ) != IsPositiveFloat assert 0.0 != IsPositiveFloat assert - 1.0 != IsPositiveFloat IsNegativeFloat \u00b6 Bases: IsFloat Like IsNegative but only for float s. IsNegativeFloat from decimal import Decimal from dirty_equals import IsNegativeFloat assert - 1.0 == IsNegativeFloat assert - 1 != IsNegativeFloat assert Decimal ( '-3.14' ) != IsNegativeFloat assert 0.0 != IsNegativeFloat assert 1.0 != IsNegativeFloat IsFloatInf \u00b6 Bases: IsFloat Checks that a value is float and infinite (positive or negative). Inherits from IsFloat . IsFloatInf from dirty_equals import IsFloatInf assert float ( 'inf' ) == IsFloatInf assert float ( '-inf' ) == IsFloatInf assert 1.0 != IsFloatInf IsFloatInfPos \u00b6 Bases: IsFloatInf Checks that a value is float and positive infinite. Inherits from IsFloatInf . IsFloatInfPos from dirty_equals import IsFloatInfPos assert float ( 'inf' ) == IsFloatInfPos assert - float ( '-inf' ) == IsFloatInfPos assert - float ( 'inf' ) != IsFloatInfPos assert float ( '-inf' ) != IsFloatInfPos IsFloatInfNeg \u00b6 Bases: IsFloatInf Checks that a value is float and negative infinite. Inherits from IsFloatInf . IsFloatInfNeg from dirty_equals import IsFloatInfNeg assert - float ( 'inf' ) == IsFloatInfNeg assert float ( '-inf' ) == IsFloatInfNeg assert float ( 'inf' ) != IsFloatInfNeg assert - float ( '-inf' ) != IsFloatInfNeg IsFloatNan \u00b6 Bases: IsFloat Checks that a value is float and nan (not a number). Inherits from IsFloat . IsFloatNan from dirty_equals import IsFloatNan assert float ( 'nan' ) == IsFloatNan assert 1.0 != IsFloatNan IsApprox \u00b6 IsApprox ( approx : Num , * , delta : Optional [ Num ] = None ) Bases: IsNumber Simplified subclass of IsNumber that only allows approximate comparisons. Parameters: Name Type Description Default approx Num A value to approximately compare to. required delta Optional [ Num ] The allowable different when comparing to the value to approx , if omitted value / 100 is used. None IsApprox from dirty_equals import IsApprox assert 1.0 == IsApprox ( 1 ) assert 123 == IsApprox ( 120 , delta = 4 ) assert 201 == IsApprox ( 200 ) assert 201 != IsApprox ( 200 , delta = 0.1 ) IsNumber \u00b6 Bases: IsNumeric [ AnyNumber ] Base class for all types that can be used with all number types, e.g. numeric but not date or datetime . Inherits from IsNumeric and can therefore be initialised with any of its arguments. allowed_types class-attribute \u00b6 allowed_types = ( int , float , Decimal ) It allows any of the number types. IsNumeric \u00b6 IsNumeric ( * , exactly : Optional [ N ] = None , approx : Optional [ N ] = None , delta : Optional [ N ] = None , gt : Optional [ N ] = None , lt : Optional [ N ] = None , ge : Optional [ N ] = None , le : Optional [ N ] = None ) Bases: DirtyEquals [ N ] Base class for all numeric types, IsNumeric implements approximate and inequality comparisons, as well as the type checks. This class can be used directly or via any of its subclasses. Parameters: Name Type Description Default exactly Optional [ N ] A value to exactly compare to - useful when you want to make sure a value is an int or float , while also checking its value. None approx Optional [ N ] A value to approximately compare to. None delta Optional [ N ] The allowable different when comparing to the value to approx , if omitted value / 100 is used except for datetimes where 2 seconds is used. None gt Optional [ N ] Value which the compared value should be greater than. None lt Optional [ N ] Value which the compared value should be less than. None ge Optional [ N ] Value which the compared value should be greater than or equal to. None le Optional [ N ] Value which the compared value should be less than or equal to. None If not values are provided, only the type is checked. If approx is provided as well a gt , lt , ge , or le , a TypeError is raised. Example of direct usage: IsNumeric from datetime import datetime from dirty_equals import IsNumeric assert 1.0 == IsNumeric assert 4 == IsNumeric ( gt = 3 ) d = datetime ( 2020 , 1 , 1 , 12 , 0 , 0 ) assert d == IsNumeric ( approx = datetime ( 2020 , 1 , 1 , 12 , 0 , 1 )) allowed_types class-attribute \u00b6 allowed_types : Union [ Type [ N ], Tuple [ type , ... ]] = ( int , float , Decimal , date , datetime , ) It allows any of the types supported in its subclasses.","title":"Numeric Types"},{"location":"types/numeric/#numeric-types","text":"","title":"Numeric Types"},{"location":"types/numeric/#dirty_equals.IsInt","text":"Bases: IsNumeric [ int ] Checks that a value is an integer. Inherits from IsNumeric and can therefore be initialised with any of its arguments. IsInt from dirty_equals import IsInt assert 1 == IsInt assert - 2 == IsInt assert 1.0 != IsInt assert 'foobar' != IsInt assert True != IsInt assert 1 == IsInt ( exactly = 1 ) assert - 2 != IsInt ( exactly = 1 )","title":"IsInt"},{"location":"types/numeric/#dirty_equals._numeric.IsInt.allowed_types","text":"As the name suggests, only integers are allowed, booleans ( True are False ) are explicitly excluded although technically they are sub-types of int .","title":"allowed_types"},{"location":"types/numeric/#dirty_equals.IsFloat","text":"Bases: IsNumeric [ float ] Checks that a value is a float. Inherits from IsNumeric and can therefore be initialised with any of its arguments. IsFloat from dirty_equals import IsFloat assert 1.0 == IsFloat assert 1 != IsFloat assert 1.0 == IsFloat ( exactly = 1.0 ) assert 1.001 != IsFloat ( exactly = 1.0 )","title":"IsFloat"},{"location":"types/numeric/#dirty_equals._numeric.IsFloat.allowed_types","text":"As the name suggests, only floats are allowed.","title":"allowed_types"},{"location":"types/numeric/#dirty_equals.IsPositive","text":"Bases: IsNumber Check that a value is positive ( > 0 ), can be an int , a float or a Decimal (or indeed any value which implements __gt__ for 0 ). IsPositive from decimal import Decimal from dirty_equals import IsPositive assert 1.0 == IsPositive assert 1 == IsPositive assert Decimal ( '3.14' ) == IsPositive assert 0 != IsPositive assert - 1 != IsPositive","title":"IsPositive"},{"location":"types/numeric/#dirty_equals.IsNegative","text":"Bases: IsNumber Check that a value is negative ( < 0 ), can be an int , a float or a Decimal (or indeed any value which implements __lt__ for 0 ). IsNegative from decimal import Decimal from dirty_equals import IsNegative assert - 1.0 == IsNegative assert - 1 == IsNegative assert Decimal ( '-3.14' ) == IsNegative assert 0 != IsNegative assert 1 != IsNegative","title":"IsNegative"},{"location":"types/numeric/#dirty_equals.IsNonNegative","text":"Bases: IsNumber Check that a value is positive or zero ( >= 0 ), can be an int , a float or a Decimal (or indeed any value which implements __ge__ for 0 ). IsNonNegative from decimal import Decimal from dirty_equals import IsNonNegative assert 1.0 == IsNonNegative assert 1 == IsNonNegative assert Decimal ( '3.14' ) == IsNonNegative assert 0 == IsNonNegative assert - 1 != IsNonNegative assert Decimal ( '0' ) == IsNonNegative","title":"IsNonNegative"},{"location":"types/numeric/#dirty_equals.IsNonPositive","text":"Bases: IsNumber Check that a value is negative or zero ( <=0 ), can be an int , a float or a Decimal (or indeed any value which implements __le__ for 0 ). IsNonPositive from decimal import Decimal from dirty_equals import IsNonPositive assert - 1.0 == IsNonPositive assert - 1 == IsNonPositive assert Decimal ( '-3.14' ) == IsNonPositive assert 0 == IsNonPositive assert 1 != IsNonPositive assert Decimal ( '-0' ) == IsNonPositive assert Decimal ( '0' ) == IsNonPositive","title":"IsNonPositive"},{"location":"types/numeric/#dirty_equals.IsPositiveInt","text":"Bases: IsInt Like IsPositive but only for int s. IsPositiveInt from decimal import Decimal from dirty_equals import IsPositiveInt assert 1 == IsPositiveInt assert 1.0 != IsPositiveInt assert Decimal ( '3.14' ) != IsPositiveInt assert 0 != IsPositiveInt assert - 1 != IsPositiveInt","title":"IsPositiveInt"},{"location":"types/numeric/#dirty_equals.IsNegativeInt","text":"Bases: IsInt Like IsNegative but only for int s. IsNegativeInt from decimal import Decimal from dirty_equals import IsNegativeInt assert - 1 == IsNegativeInt assert - 1.0 != IsNegativeInt assert Decimal ( '-3.14' ) != IsNegativeInt assert 0 != IsNegativeInt assert 1 != IsNegativeInt","title":"IsNegativeInt"},{"location":"types/numeric/#dirty_equals.IsPositiveFloat","text":"Bases: IsFloat Like IsPositive but only for float s. IsPositiveFloat from decimal import Decimal from dirty_equals import IsPositiveFloat assert 1.0 == IsPositiveFloat assert 1 != IsPositiveFloat assert Decimal ( '3.14' ) != IsPositiveFloat assert 0.0 != IsPositiveFloat assert - 1.0 != IsPositiveFloat","title":"IsPositiveFloat"},{"location":"types/numeric/#dirty_equals.IsNegativeFloat","text":"Bases: IsFloat Like IsNegative but only for float s. IsNegativeFloat from decimal import Decimal from dirty_equals import IsNegativeFloat assert - 1.0 == IsNegativeFloat assert - 1 != IsNegativeFloat assert Decimal ( '-3.14' ) != IsNegativeFloat assert 0.0 != IsNegativeFloat assert 1.0 != IsNegativeFloat","title":"IsNegativeFloat"},{"location":"types/numeric/#dirty_equals.IsFloatInf","text":"Bases: IsFloat Checks that a value is float and infinite (positive or negative). Inherits from IsFloat . IsFloatInf from dirty_equals import IsFloatInf assert float ( 'inf' ) == IsFloatInf assert float ( '-inf' ) == IsFloatInf assert 1.0 != IsFloatInf","title":"IsFloatInf"},{"location":"types/numeric/#dirty_equals.IsFloatInfPos","text":"Bases: IsFloatInf Checks that a value is float and positive infinite. Inherits from IsFloatInf . IsFloatInfPos from dirty_equals import IsFloatInfPos assert float ( 'inf' ) == IsFloatInfPos assert - float ( '-inf' ) == IsFloatInfPos assert - float ( 'inf' ) != IsFloatInfPos assert float ( '-inf' ) != IsFloatInfPos","title":"IsFloatInfPos"},{"location":"types/numeric/#dirty_equals.IsFloatInfNeg","text":"Bases: IsFloatInf Checks that a value is float and negative infinite. Inherits from IsFloatInf . IsFloatInfNeg from dirty_equals import IsFloatInfNeg assert - float ( 'inf' ) == IsFloatInfNeg assert float ( '-inf' ) == IsFloatInfNeg assert float ( 'inf' ) != IsFloatInfNeg assert - float ( '-inf' ) != IsFloatInfNeg","title":"IsFloatInfNeg"},{"location":"types/numeric/#dirty_equals.IsFloatNan","text":"Bases: IsFloat Checks that a value is float and nan (not a number). Inherits from IsFloat . IsFloatNan from dirty_equals import IsFloatNan assert float ( 'nan' ) == IsFloatNan assert 1.0 != IsFloatNan","title":"IsFloatNan"},{"location":"types/numeric/#dirty_equals.IsApprox","text":"IsApprox ( approx : Num , * , delta : Optional [ Num ] = None ) Bases: IsNumber Simplified subclass of IsNumber that only allows approximate comparisons. Parameters: Name Type Description Default approx Num A value to approximately compare to. required delta Optional [ Num ] The allowable different when comparing to the value to approx , if omitted value / 100 is used. None IsApprox from dirty_equals import IsApprox assert 1.0 == IsApprox ( 1 ) assert 123 == IsApprox ( 120 , delta = 4 ) assert 201 == IsApprox ( 200 ) assert 201 != IsApprox ( 200 , delta = 0.1 )","title":"IsApprox"},{"location":"types/numeric/#dirty_equals.IsNumber","text":"Bases: IsNumeric [ AnyNumber ] Base class for all types that can be used with all number types, e.g. numeric but not date or datetime . Inherits from IsNumeric and can therefore be initialised with any of its arguments.","title":"IsNumber"},{"location":"types/numeric/#dirty_equals._numeric.IsNumber.allowed_types","text":"allowed_types = ( int , float , Decimal ) It allows any of the number types.","title":"allowed_types"},{"location":"types/numeric/#dirty_equals.IsNumeric","text":"IsNumeric ( * , exactly : Optional [ N ] = None , approx : Optional [ N ] = None , delta : Optional [ N ] = None , gt : Optional [ N ] = None , lt : Optional [ N ] = None , ge : Optional [ N ] = None , le : Optional [ N ] = None ) Bases: DirtyEquals [ N ] Base class for all numeric types, IsNumeric implements approximate and inequality comparisons, as well as the type checks. This class can be used directly or via any of its subclasses. Parameters: Name Type Description Default exactly Optional [ N ] A value to exactly compare to - useful when you want to make sure a value is an int or float , while also checking its value. None approx Optional [ N ] A value to approximately compare to. None delta Optional [ N ] The allowable different when comparing to the value to approx , if omitted value / 100 is used except for datetimes where 2 seconds is used. None gt Optional [ N ] Value which the compared value should be greater than. None lt Optional [ N ] Value which the compared value should be less than. None ge Optional [ N ] Value which the compared value should be greater than or equal to. None le Optional [ N ] Value which the compared value should be less than or equal to. None If not values are provided, only the type is checked. If approx is provided as well a gt , lt , ge , or le , a TypeError is raised. Example of direct usage: IsNumeric from datetime import datetime from dirty_equals import IsNumeric assert 1.0 == IsNumeric assert 4 == IsNumeric ( gt = 3 ) d = datetime ( 2020 , 1 , 1 , 12 , 0 , 0 ) assert d == IsNumeric ( approx = datetime ( 2020 , 1 , 1 , 12 , 0 , 1 ))","title":"IsNumeric"},{"location":"types/numeric/#dirty_equals._numeric.IsNumeric.allowed_types","text":"allowed_types : Union [ Type [ N ], Tuple [ type , ... ]] = ( int , float , Decimal , date , datetime , ) It allows any of the types supported in its subclasses.","title":"allowed_types"},{"location":"types/other/","text":"Other Types \u00b6 FunctionCheck \u00b6 FunctionCheck ( func : Callable [[ Any ], bool ]) Bases: DirtyEquals [ Any ] Use a function to check if a value \"equals\" whatever you want to check Parameters: Name Type Description Default func Callable [[ Any ], bool ] callable that takes a value and returns a bool. required FunctionCheck from dirty_equals import FunctionCheck def is_even ( x ): return x % 2 == 0 assert 2 == FunctionCheck ( is_even ) assert 3 != FunctionCheck ( is_even ) IsInstance \u00b6 IsInstance ( expected_type : ExpectedType , * , only_direct_instance : bool = False ) Bases: DirtyEquals [ ExpectedType ] A type which checks that the value is an instance of the expected type. Parameters: Name Type Description Default expected_type ExpectedType The type to check against. required only_direct_instance bool whether instances of subclasses of expected_type should be considered equal. False Note IsInstance can be parameterized or initialised with a type - IsInstance[Foo] is exactly equivalent to IsInstance(Foo) . This allows usage to be analogous to type hints. Example: IsInstance from dirty_equals import IsInstance class Foo : pass class Bar ( Foo ): pass assert Foo () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo ) assert Foo != IsInstance [ Bar ] assert Bar () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo , only_direct_instance = True ) assert Bar () != IsInstance ( Foo , only_direct_instance = True ) IsJson \u00b6 IsJson ( expected_value : JsonType = AnyJson , ** expected_kwargs : Any ) Bases: DirtyEquals [ JsonType ] A class that checks if a value is a JSON object, and check the contents of the JSON. Parameters: Name Type Description Default expected_value JsonType Value to compare the JSON to, if omitted, any JSON is accepted. AnyJson **expected_kwargs Any Keyword arguments forming a dict to compare the JSON to, expected_value and expected_kwargs may not be combined. {} As with any dirty_equals type, types can be nested to provide more complex checks. Note Like IsInstance , IsJson can be parameterized or initialised with a value - IsJson[xyz] is exactly equivalent to IsJson(xyz) . This allows usage to be analogous to type hints. IsJson from dirty_equals import IsJson , IsPositiveInt , IsStrictDict assert '{\"a\": 1, \"b\": 2}' == IsJson assert '{\"a\": 1, \"b\": 2}' == IsJson ( a = 1 , b = 2 ) assert '{\"a\": 1}' != IsJson ( a = 2 ) assert 'invalid json' != IsJson assert '{\"a\": 1}' == IsJson ( a = IsPositiveInt ) assert '\"just a quoted string\"' == IsJson ( 'just a quoted string' ) assert '{\"a\": 1, \"b\": 2}' == IsJson [ IsStrictDict ( a = 1 , b = 2 )] assert '{\"b\": 2, \"a\": 1}' != IsJson [ IsStrictDict ( a = 1 , b = 2 )] IsUUID \u00b6 IsUUID ( version : Literal [ None , 1 , 2 , 3 , 4 , 5 ] = None ) Bases: DirtyEquals [ UUID ] A class that checks if a value is a valid UUID, optionally checking UUID version. Parameters: Name Type Description Default version Literal [None, 1, 2, 3, 4, 5] The version of the UUID to check, if omitted, all versions are accepted. None IsUUID import uuid from dirty_equals import IsUUID assert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID assert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID ( 4 ) assert 'edf9f29e45c7431c99db28ea44df9785' == IsUUID ( 4 ) assert 'edf9f29e-45c7-431c-99db-28ea44df9785' != IsUUID ( 5 ) assert uuid . uuid4 () == IsUUID ( 4 ) AnyThing \u00b6 Bases: DirtyEquals [ Any ] A type which matches any value. AnyThing isn't generally very useful on its own, but can be used within other comparisons. AnyThing from dirty_equals import AnyThing , IsList , IsStrictDict assert 1 == AnyThing assert 'foobar' == AnyThing assert [ 1 , 2 , 3 ] == AnyThing assert [ 1 , 2 , 3 ] == IsList ( AnyThing , 2 , 3 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } == IsStrictDict ( a = 1 , b = AnyThing , c = 3 ) IsOneOf \u00b6 IsOneOf ( expected_value : Any , * more_expected_values : Any ) Bases: DirtyEquals [ Any ] A type which checks that the value is equal to one of the given values. Can be useful with boolean operators. Parameters: Name Type Description Default expected_value Any Expected value for equals to return true. required *more_expected_values Any More expected values for equals to return true. () IsOneOf from dirty_equals import Contains , IsOneOf assert 1 == IsOneOf ( 1 , 2 , 3 ) assert 4 != IsOneOf ( 1 , 2 , 3 ) # check that a list either contain 1 or is empty assert [ 1 , 2 , 3 ] == Contains ( 1 ) | IsOneOf ([]) assert [] == Contains ( 1 ) | IsOneOf ([]) IsUrl \u00b6 IsUrl ( any_url : bool = False , any_http_url : bool = False , http_url : bool = False , file_url : bool = False , postgres_dsn : bool = False , ampqp_dsn : bool = False , redis_dsn : bool = False , ** expected_attributes : Any ) Bases: DirtyEquals [ str ] A class that checks if a value is a valid URL, optionally checking different URL types and attributes with Pydantic . Parameters: Name Type Description Default any_url bool any scheme allowed, TLD not required, host required False any_http_url bool scheme http or https, TLD not required, host required False http_url bool scheme http or https, TLD required, host required, max length 2083 False file_url bool scheme file, host not required False postgres_dsn bool user info required, TLD not required False ampqp_dsn bool schema amqp or amqps, user info not required, TLD not required, host not required False redis_dsn bool scheme redis or rediss, user info not required, tld not required, host not required False **expected_attributes Any Expected values for url attributes {} IsUrl from dirty_equals import IsUrl assert 'https://example.com' == IsUrl assert 'https://example.com' == IsUrl ( tld = 'com' ) assert 'https://example.com' == IsUrl ( scheme = 'https' ) assert 'https://example.com' != IsUrl ( scheme = 'http' ) assert 'postgres://user:pass@localhost:5432/app' == IsUrl ( postgres_dsn = True ) assert 'postgres://user:pass@localhost:5432/app' != IsUrl ( http_url = True ) IsHash \u00b6 IsHash ( hash_type : HashTypes ) Bases: DirtyEquals [ str ] A class that checks if a value is a valid common hash type, using a simple length and allowed characters regex. Parameters: Name Type Description Default hash_type HashTypes The hash type to check. Must be specified. required IsHash from dirty_equals import IsHash assert 'f1e069787ece74531d112559945c6871' == IsHash ( 'md5' ) assert b 'f1e069787ece74531d112559945c6871' == IsHash ( 'md5' ) assert 'f1e069787ece74531d112559945c6871' != IsHash ( 'sha-256' ) assert 'F1E069787ECE74531D112559945C6871' == IsHash ( 'md5' ) assert '40bd001563085fc35165329ea1ff5c5ecbdbbeef' == IsHash ( 'sha-1' ) assert 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3' == IsHash ( 'sha-256' ) IsIP \u00b6 IsIP ( * , version : Literal [ None , 4 , 6 ] = None , netmask : Optional [ str ] = None ) Bases: DirtyEquals [ IP ] A class that checks if a value is a valid IP address, optionally checking IP version, netmask. Parameters: Name Type Description Default version Literal [None, 4, 6] The version of the IP to check, if omitted, versions 4 and 6 are both accepted. None netmask Optional [ str ] The netmask of the IP to check, if omitted, any netmask is accepted. Requires version. None IsIP from ipaddress import IPv4Address , IPv4Network , IPv6Address from dirty_equals import IsIP assert '179.27.154.96' == IsIP assert '179.27.154.96' == IsIP ( version = 4 ) assert '2001:0db8:0a0b:12f0:0000:0000:0000:0001' == IsIP ( version = 6 ) assert IPv4Address ( '127.0.0.1' ) == IsIP assert IPv4Network ( '43.48.0.0/12' ) == IsIP assert IPv6Address ( '::eeff:ae3f:d473' ) == IsIP assert '54.43.53.219/10' == IsIP ( version = 4 , netmask = '255.192.0.0' ) assert '54.43.53.219/10' == IsIP ( version = 4 , netmask = 4290772992 ) assert '::ffff:aebf:d473/12' == IsIP ( version = 6 , netmask = 'fff0::' ) assert 3232235521 == IsIP","title":"Other Types"},{"location":"types/other/#other-types","text":"","title":"Other Types"},{"location":"types/other/#dirty_equals.FunctionCheck","text":"FunctionCheck ( func : Callable [[ Any ], bool ]) Bases: DirtyEquals [ Any ] Use a function to check if a value \"equals\" whatever you want to check Parameters: Name Type Description Default func Callable [[ Any ], bool ] callable that takes a value and returns a bool. required FunctionCheck from dirty_equals import FunctionCheck def is_even ( x ): return x % 2 == 0 assert 2 == FunctionCheck ( is_even ) assert 3 != FunctionCheck ( is_even )","title":"FunctionCheck"},{"location":"types/other/#dirty_equals.IsInstance","text":"IsInstance ( expected_type : ExpectedType , * , only_direct_instance : bool = False ) Bases: DirtyEquals [ ExpectedType ] A type which checks that the value is an instance of the expected type. Parameters: Name Type Description Default expected_type ExpectedType The type to check against. required only_direct_instance bool whether instances of subclasses of expected_type should be considered equal. False Note IsInstance can be parameterized or initialised with a type - IsInstance[Foo] is exactly equivalent to IsInstance(Foo) . This allows usage to be analogous to type hints. Example: IsInstance from dirty_equals import IsInstance class Foo : pass class Bar ( Foo ): pass assert Foo () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo ) assert Foo != IsInstance [ Bar ] assert Bar () == IsInstance [ Foo ] assert Foo () == IsInstance ( Foo , only_direct_instance = True ) assert Bar () != IsInstance ( Foo , only_direct_instance = True )","title":"IsInstance"},{"location":"types/other/#dirty_equals.IsJson","text":"IsJson ( expected_value : JsonType = AnyJson , ** expected_kwargs : Any ) Bases: DirtyEquals [ JsonType ] A class that checks if a value is a JSON object, and check the contents of the JSON. Parameters: Name Type Description Default expected_value JsonType Value to compare the JSON to, if omitted, any JSON is accepted. AnyJson **expected_kwargs Any Keyword arguments forming a dict to compare the JSON to, expected_value and expected_kwargs may not be combined. {} As with any dirty_equals type, types can be nested to provide more complex checks. Note Like IsInstance , IsJson can be parameterized or initialised with a value - IsJson[xyz] is exactly equivalent to IsJson(xyz) . This allows usage to be analogous to type hints. IsJson from dirty_equals import IsJson , IsPositiveInt , IsStrictDict assert '{\"a\": 1, \"b\": 2}' == IsJson assert '{\"a\": 1, \"b\": 2}' == IsJson ( a = 1 , b = 2 ) assert '{\"a\": 1}' != IsJson ( a = 2 ) assert 'invalid json' != IsJson assert '{\"a\": 1}' == IsJson ( a = IsPositiveInt ) assert '\"just a quoted string\"' == IsJson ( 'just a quoted string' ) assert '{\"a\": 1, \"b\": 2}' == IsJson [ IsStrictDict ( a = 1 , b = 2 )] assert '{\"b\": 2, \"a\": 1}' != IsJson [ IsStrictDict ( a = 1 , b = 2 )]","title":"IsJson"},{"location":"types/other/#dirty_equals.IsUUID","text":"IsUUID ( version : Literal [ None , 1 , 2 , 3 , 4 , 5 ] = None ) Bases: DirtyEquals [ UUID ] A class that checks if a value is a valid UUID, optionally checking UUID version. Parameters: Name Type Description Default version Literal [None, 1, 2, 3, 4, 5] The version of the UUID to check, if omitted, all versions are accepted. None IsUUID import uuid from dirty_equals import IsUUID assert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID assert 'edf9f29e-45c7-431c-99db-28ea44df9785' == IsUUID ( 4 ) assert 'edf9f29e45c7431c99db28ea44df9785' == IsUUID ( 4 ) assert 'edf9f29e-45c7-431c-99db-28ea44df9785' != IsUUID ( 5 ) assert uuid . uuid4 () == IsUUID ( 4 )","title":"IsUUID"},{"location":"types/other/#dirty_equals.AnyThing","text":"Bases: DirtyEquals [ Any ] A type which matches any value. AnyThing isn't generally very useful on its own, but can be used within other comparisons. AnyThing from dirty_equals import AnyThing , IsList , IsStrictDict assert 1 == AnyThing assert 'foobar' == AnyThing assert [ 1 , 2 , 3 ] == AnyThing assert [ 1 , 2 , 3 ] == IsList ( AnyThing , 2 , 3 ) assert { 'a' : 1 , 'b' : 2 , 'c' : 3 } == IsStrictDict ( a = 1 , b = AnyThing , c = 3 )","title":"AnyThing"},{"location":"types/other/#dirty_equals.IsOneOf","text":"IsOneOf ( expected_value : Any , * more_expected_values : Any ) Bases: DirtyEquals [ Any ] A type which checks that the value is equal to one of the given values. Can be useful with boolean operators. Parameters: Name Type Description Default expected_value Any Expected value for equals to return true. required *more_expected_values Any More expected values for equals to return true. () IsOneOf from dirty_equals import Contains , IsOneOf assert 1 == IsOneOf ( 1 , 2 , 3 ) assert 4 != IsOneOf ( 1 , 2 , 3 ) # check that a list either contain 1 or is empty assert [ 1 , 2 , 3 ] == Contains ( 1 ) | IsOneOf ([]) assert [] == Contains ( 1 ) | IsOneOf ([])","title":"IsOneOf"},{"location":"types/other/#dirty_equals.IsUrl","text":"IsUrl ( any_url : bool = False , any_http_url : bool = False , http_url : bool = False , file_url : bool = False , postgres_dsn : bool = False , ampqp_dsn : bool = False , redis_dsn : bool = False , ** expected_attributes : Any ) Bases: DirtyEquals [ str ] A class that checks if a value is a valid URL, optionally checking different URL types and attributes with Pydantic . Parameters: Name Type Description Default any_url bool any scheme allowed, TLD not required, host required False any_http_url bool scheme http or https, TLD not required, host required False http_url bool scheme http or https, TLD required, host required, max length 2083 False file_url bool scheme file, host not required False postgres_dsn bool user info required, TLD not required False ampqp_dsn bool schema amqp or amqps, user info not required, TLD not required, host not required False redis_dsn bool scheme redis or rediss, user info not required, tld not required, host not required False **expected_attributes Any Expected values for url attributes {} IsUrl from dirty_equals import IsUrl assert 'https://example.com' == IsUrl assert 'https://example.com' == IsUrl ( tld = 'com' ) assert 'https://example.com' == IsUrl ( scheme = 'https' ) assert 'https://example.com' != IsUrl ( scheme = 'http' ) assert 'postgres://user:pass@localhost:5432/app' == IsUrl ( postgres_dsn = True ) assert 'postgres://user:pass@localhost:5432/app' != IsUrl ( http_url = True )","title":"IsUrl"},{"location":"types/other/#dirty_equals.IsHash","text":"IsHash ( hash_type : HashTypes ) Bases: DirtyEquals [ str ] A class that checks if a value is a valid common hash type, using a simple length and allowed characters regex. Parameters: Name Type Description Default hash_type HashTypes The hash type to check. Must be specified. required IsHash from dirty_equals import IsHash assert 'f1e069787ece74531d112559945c6871' == IsHash ( 'md5' ) assert b 'f1e069787ece74531d112559945c6871' == IsHash ( 'md5' ) assert 'f1e069787ece74531d112559945c6871' != IsHash ( 'sha-256' ) assert 'F1E069787ECE74531D112559945C6871' == IsHash ( 'md5' ) assert '40bd001563085fc35165329ea1ff5c5ecbdbbeef' == IsHash ( 'sha-1' ) assert 'a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3' == IsHash ( 'sha-256' )","title":"IsHash"},{"location":"types/other/#dirty_equals.IsIP","text":"IsIP ( * , version : Literal [ None , 4 , 6 ] = None , netmask : Optional [ str ] = None ) Bases: DirtyEquals [ IP ] A class that checks if a value is a valid IP address, optionally checking IP version, netmask. Parameters: Name Type Description Default version Literal [None, 4, 6] The version of the IP to check, if omitted, versions 4 and 6 are both accepted. None netmask Optional [ str ] The netmask of the IP to check, if omitted, any netmask is accepted. Requires version. None IsIP from ipaddress import IPv4Address , IPv4Network , IPv6Address from dirty_equals import IsIP assert '179.27.154.96' == IsIP assert '179.27.154.96' == IsIP ( version = 4 ) assert '2001:0db8:0a0b:12f0:0000:0000:0000:0001' == IsIP ( version = 6 ) assert IPv4Address ( '127.0.0.1' ) == IsIP assert IPv4Network ( '43.48.0.0/12' ) == IsIP assert IPv6Address ( '::eeff:ae3f:d473' ) == IsIP assert '54.43.53.219/10' == IsIP ( version = 4 , netmask = '255.192.0.0' ) assert '54.43.53.219/10' == IsIP ( version = 4 , netmask = 4290772992 ) assert '::ffff:aebf:d473/12' == IsIP ( version = 6 , netmask = 'fff0::' ) assert 3232235521 == IsIP","title":"IsIP"},{"location":"types/sequence/","text":"Sequence Types \u00b6 IsListOrTuple \u00b6 IsListOrTuple ( * items : Any , positions : Optional [ Dict [ int , Any ]] = None , check_order : bool = True , length : LengthType = None ) Bases: DirtyEquals [ T ] Check that some object is a list or tuple and optionally its values match some constraints. IsListOrTuple and its subclasses can be initialised in two ways: Parameters: Name Type Description Default *items Any Positional members of an object to check. These must start from the zeroth position, but (depending on the value of length ) may not include all values of the list/tuple being checked. () check_order bool Whether to enforce the order of the items. True length Union [ int , Tuple [ int , Union [ int , Any ]]] length constraints, int or tuple matching the arguments of HasLen . None or, Parameters: Name Type Description Default positions Dict [ int , Any ] Instead of *items , a dictionary of positions and values to check and be provided. None length Union [ int , Tuple [ int , Union [ int , Any ]]] length constraints, int or tuple matching the arguments of HasLen . None IsListOrTuple from dirty_equals import AnyThing , IsListOrTuple assert [ 1 , 2 , 3 ] == IsListOrTuple ( 1 , 2 , 3 ) assert ( 1 , 3 , 2 ) == IsListOrTuple ( 1 , 2 , 3 , check_order = False ) assert [{ 'a' : 1 }, { 'a' : 2 }] == ( IsListOrTuple ({ 'a' : 2 }, { 'a' : 1 }, check_order = False ) # (1)! ) assert [ 1 , 2 , 3 , 3 ] != IsListOrTuple ( 1 , 2 , 3 , check_order = False ) # (2)! assert [ 1 , 2 , 3 , 4 , 5 ] == IsListOrTuple ( 1 , 2 , 3 , length =... ) # (3)! assert [ 1 , 2 , 3 , 4 , 5 ] != IsListOrTuple ( 1 , 2 , 3 , length = ( 8 , 10 )) # (4)! assert [ 'a' , 'b' , 'c' , 'd' ] == ( IsListOrTuple ( positions = { 2 : 'c' , 3 : 'd' })) # (5)! assert [ 'a' , 'b' , 'c' , 'd' ] == ( IsListOrTuple ( positions = { 2 : 'c' , 3 : 'd' }, length = 4 ) # (6)! ) assert [ 1 , 2 , 3 , 4 ] == IsListOrTuple ( 3 , check_order = False , length = ( 0 , ... )) # (7)! assert [ 1 , 2 , 3 ] == IsListOrTuple ( AnyThing , AnyThing , 3 ) # (8)! Unlike using sets for comparison, we can do order-insensitive comparisons on objects that are not hashable. And we won't get caught out by duplicate values Here we're just checking the first 3 items, the compared list or tuple can be of any length Compared list is not long enough Compare using positions , here no length if enforced Compare using positions but with a length constraint Here we're just confirming that the value 3 is in the list If you don't care about the first few values of a list or tuple, you can use AnyThing in your arguments. IsList \u00b6 Bases: IsListOrTuple [ List [ Any ]] All the same functionality as IsListOrTuple , but the compared value must be a list. IsList from dirty_equals import IsList assert [ 1 , 2 , 3 ] == IsList ( 1 , 2 , 3 ) assert [ 1 , 2 , 3 ] == IsList ( positions = { 2 : 3 }) assert [ 1 , 2 , 3 ] == IsList ( 1 , 2 , 3 , check_order = False ) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length = 4 ) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length = ( 4 , 5 )) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length =... ) assert ( 1 , 2 , 3 ) != IsList ( 1 , 2 , 3 ) IsTuple \u00b6 Bases: IsListOrTuple [ Tuple [ Any , ...]] All the same functionality as IsListOrTuple , but the compared value must be a tuple. IsTuple from dirty_equals import IsTuple assert ( 1 , 2 , 3 ) == IsTuple ( 1 , 2 , 3 ) assert ( 1 , 2 , 3 ) == IsTuple ( positions = { 2 : 3 }) assert ( 1 , 2 , 3 ) == IsTuple ( 1 , 2 , 3 , check_order = False ) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length = 4 ) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length = ( 4 , 5 )) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length =... ) assert [ 1 , 2 , 3 ] != IsTuple ( 1 , 2 , 3 ) HasLen \u00b6 HasLen ( min_length : int , max_length : Union [ None , int , Any ] = None , ) Bases: DirtyEquals [ Sized ] Check that some has a given length, or length in a given range. Parameters: Name Type Description Default min_length int Expected length if max_length is not given, else minimum length. required max_length Union [None, int , Any ] Expected maximum length, use an ellipsis ... to indicate that there's no maximum. None HasLen from dirty_equals import HasLen assert [ 1 , 2 , 3 ] == HasLen ( 3 ) # (1)! assert '123' == HasLen ( 3 , ... ) # (2)! assert ( 1 , 2 , 3 ) == HasLen ( 3 , 5 ) # (3)! assert ( 1 , 2 , 3 ) == HasLen ( 0 , ... ) # (4)! Length must be 3. Length must be 3 or higher. Length must be between 3 and 5 inclusive. Length is required but can take any value. Contains \u00b6 Contains ( contained_value : Any , * more_contained_values : Any ) Bases: DirtyEquals [ Container [ Any ]] Check that an object contains one or more values. Parameters: Name Type Description Default contained_value Any value that must be contained in the compared object. required *more_contained_values Any more values that must be contained in the compared object. () Contains from dirty_equals import Contains assert [ 1 , 2 , 3 ] == Contains ( 1 ) assert [ 1 , 2 , 3 ] == Contains ( 1 , 2 ) assert ( 1 , 2 , 3 ) == Contains ( 1 ) assert 'abc' == Contains ( 'b' ) assert { 'a' : 1 , 'b' : 2 } == Contains ( 'a' ) assert [ 1 , 2 , 3 ] != Contains ( 10 )","title":"Sequence Types"},{"location":"types/sequence/#sequence-types","text":"","title":"Sequence Types"},{"location":"types/sequence/#dirty_equals.IsListOrTuple","text":"IsListOrTuple ( * items : Any , positions : Optional [ Dict [ int , Any ]] = None , check_order : bool = True , length : LengthType = None ) Bases: DirtyEquals [ T ] Check that some object is a list or tuple and optionally its values match some constraints. IsListOrTuple and its subclasses can be initialised in two ways: Parameters: Name Type Description Default *items Any Positional members of an object to check. These must start from the zeroth position, but (depending on the value of length ) may not include all values of the list/tuple being checked. () check_order bool Whether to enforce the order of the items. True length Union [ int , Tuple [ int , Union [ int , Any ]]] length constraints, int or tuple matching the arguments of HasLen . None or, Parameters: Name Type Description Default positions Dict [ int , Any ] Instead of *items , a dictionary of positions and values to check and be provided. None length Union [ int , Tuple [ int , Union [ int , Any ]]] length constraints, int or tuple matching the arguments of HasLen . None IsListOrTuple from dirty_equals import AnyThing , IsListOrTuple assert [ 1 , 2 , 3 ] == IsListOrTuple ( 1 , 2 , 3 ) assert ( 1 , 3 , 2 ) == IsListOrTuple ( 1 , 2 , 3 , check_order = False ) assert [{ 'a' : 1 }, { 'a' : 2 }] == ( IsListOrTuple ({ 'a' : 2 }, { 'a' : 1 }, check_order = False ) # (1)! ) assert [ 1 , 2 , 3 , 3 ] != IsListOrTuple ( 1 , 2 , 3 , check_order = False ) # (2)! assert [ 1 , 2 , 3 , 4 , 5 ] == IsListOrTuple ( 1 , 2 , 3 , length =... ) # (3)! assert [ 1 , 2 , 3 , 4 , 5 ] != IsListOrTuple ( 1 , 2 , 3 , length = ( 8 , 10 )) # (4)! assert [ 'a' , 'b' , 'c' , 'd' ] == ( IsListOrTuple ( positions = { 2 : 'c' , 3 : 'd' })) # (5)! assert [ 'a' , 'b' , 'c' , 'd' ] == ( IsListOrTuple ( positions = { 2 : 'c' , 3 : 'd' }, length = 4 ) # (6)! ) assert [ 1 , 2 , 3 , 4 ] == IsListOrTuple ( 3 , check_order = False , length = ( 0 , ... )) # (7)! assert [ 1 , 2 , 3 ] == IsListOrTuple ( AnyThing , AnyThing , 3 ) # (8)! Unlike using sets for comparison, we can do order-insensitive comparisons on objects that are not hashable. And we won't get caught out by duplicate values Here we're just checking the first 3 items, the compared list or tuple can be of any length Compared list is not long enough Compare using positions , here no length if enforced Compare using positions but with a length constraint Here we're just confirming that the value 3 is in the list If you don't care about the first few values of a list or tuple, you can use AnyThing in your arguments.","title":"IsListOrTuple"},{"location":"types/sequence/#dirty_equals.IsList","text":"Bases: IsListOrTuple [ List [ Any ]] All the same functionality as IsListOrTuple , but the compared value must be a list. IsList from dirty_equals import IsList assert [ 1 , 2 , 3 ] == IsList ( 1 , 2 , 3 ) assert [ 1 , 2 , 3 ] == IsList ( positions = { 2 : 3 }) assert [ 1 , 2 , 3 ] == IsList ( 1 , 2 , 3 , check_order = False ) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length = 4 ) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length = ( 4 , 5 )) assert [ 1 , 2 , 3 , 4 ] == IsList ( 1 , 2 , 3 , length =... ) assert ( 1 , 2 , 3 ) != IsList ( 1 , 2 , 3 )","title":"IsList"},{"location":"types/sequence/#dirty_equals.IsTuple","text":"Bases: IsListOrTuple [ Tuple [ Any , ...]] All the same functionality as IsListOrTuple , but the compared value must be a tuple. IsTuple from dirty_equals import IsTuple assert ( 1 , 2 , 3 ) == IsTuple ( 1 , 2 , 3 ) assert ( 1 , 2 , 3 ) == IsTuple ( positions = { 2 : 3 }) assert ( 1 , 2 , 3 ) == IsTuple ( 1 , 2 , 3 , check_order = False ) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length = 4 ) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length = ( 4 , 5 )) assert ( 1 , 2 , 3 , 4 ) == IsTuple ( 1 , 2 , 3 , length =... ) assert [ 1 , 2 , 3 ] != IsTuple ( 1 , 2 , 3 )","title":"IsTuple"},{"location":"types/sequence/#dirty_equals.HasLen","text":"HasLen ( min_length : int , max_length : Union [ None , int , Any ] = None , ) Bases: DirtyEquals [ Sized ] Check that some has a given length, or length in a given range. Parameters: Name Type Description Default min_length int Expected length if max_length is not given, else minimum length. required max_length Union [None, int , Any ] Expected maximum length, use an ellipsis ... to indicate that there's no maximum. None HasLen from dirty_equals import HasLen assert [ 1 , 2 , 3 ] == HasLen ( 3 ) # (1)! assert '123' == HasLen ( 3 , ... ) # (2)! assert ( 1 , 2 , 3 ) == HasLen ( 3 , 5 ) # (3)! assert ( 1 , 2 , 3 ) == HasLen ( 0 , ... ) # (4)! Length must be 3. Length must be 3 or higher. Length must be between 3 and 5 inclusive. Length is required but can take any value.","title":"HasLen"},{"location":"types/sequence/#dirty_equals.Contains","text":"Contains ( contained_value : Any , * more_contained_values : Any ) Bases: DirtyEquals [ Container [ Any ]] Check that an object contains one or more values. Parameters: Name Type Description Default contained_value Any value that must be contained in the compared object. required *more_contained_values Any more values that must be contained in the compared object. () Contains from dirty_equals import Contains assert [ 1 , 2 , 3 ] == Contains ( 1 ) assert [ 1 , 2 , 3 ] == Contains ( 1 , 2 ) assert ( 1 , 2 , 3 ) == Contains ( 1 ) assert 'abc' == Contains ( 'b' ) assert { 'a' : 1 , 'b' : 2 } == Contains ( 'a' ) assert [ 1 , 2 , 3 ] != Contains ( 10 )","title":"Contains"},{"location":"types/string/","text":"String Types \u00b6 IsAnyStr \u00b6 IsAnyStr ( * , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , case : Literal [ upper , lower , None ] = None , regex : Union [ None , T , Pattern [ T ]] = None , regex_flags : int = 0 ) Bases: DirtyEquals [ T ] Comparison of str or bytes objects. This class allow comparison with both str and bytes but is subclassed by IsStr and IsBytes which restrict comparison to str or bytes respectively. Parameters: Name Type Description Default min_length Optional [ int ] minimum length of the string/bytes None max_length Optional [ int ] maximum length of the string/bytes None case Literal [ upper , lower , None] check case of the string/bytes None regex Union [None, T , Pattern [ T ]] regular expression to match the string/bytes with, re.fullmatch is used. This can be a compiled regex, or a string or bytes. None regex_flags int optional flags for the regular expression 0 Examples: IsAnyStr from dirty_equals import IsAnyStr assert 'foobar' == IsAnyStr () assert b 'foobar' == IsAnyStr () assert 123 != IsAnyStr () assert 'foobar' == IsAnyStr ( regex = 'foo...' ) assert 'foobar' == IsAnyStr ( regex = b 'foo...' ) # (1)! assert 'foobar' == IsAnyStr ( min_length = 6 ) assert 'foobar' != IsAnyStr ( min_length = 8 ) assert 'foobar' == IsAnyStr ( case = 'lower' ) assert 'Foobar' != IsAnyStr ( case = 'lower' ) regex can be either a string or bytes, IsAnyStr will take care of conversion so checks work. IsStr \u00b6 Bases: IsAnyStr [ str ] Checks if the value is a string, and optionally meets some constraints. IsStr is a subclass of IsAnyStr and therefore allows all the same arguments. Examples: IsStr from dirty_equals import IsStr assert 'foobar' == IsStr () assert b 'foobar' != IsStr () assert 'foobar' == IsStr ( regex = 'foo...' ) assert 'FOOBAR' == IsStr ( min_length = 5 , max_length = 10 , case = 'upper' ) IsBytes \u00b6 Bases: IsAnyStr [ bytes ] Checks if the value is a bytes object, and optionally meets some constraints. IsBytes is a subclass of IsAnyStr and therefore allows all the same arguments. Examples: IsBytes from dirty_equals import IsBytes assert b 'foobar' == IsBytes () assert 'foobar' != IsBytes () assert b 'foobar' == IsBytes ( regex = b 'foo...' ) assert b 'FOOBAR' == IsBytes ( min_length = 5 , max_length = 10 , case = 'upper' )","title":"String Types"},{"location":"types/string/#string-types","text":"","title":"String Types"},{"location":"types/string/#dirty_equals.IsAnyStr","text":"IsAnyStr ( * , min_length : Optional [ int ] = None , max_length : Optional [ int ] = None , case : Literal [ upper , lower , None ] = None , regex : Union [ None , T , Pattern [ T ]] = None , regex_flags : int = 0 ) Bases: DirtyEquals [ T ] Comparison of str or bytes objects. This class allow comparison with both str and bytes but is subclassed by IsStr and IsBytes which restrict comparison to str or bytes respectively. Parameters: Name Type Description Default min_length Optional [ int ] minimum length of the string/bytes None max_length Optional [ int ] maximum length of the string/bytes None case Literal [ upper , lower , None] check case of the string/bytes None regex Union [None, T , Pattern [ T ]] regular expression to match the string/bytes with, re.fullmatch is used. This can be a compiled regex, or a string or bytes. None regex_flags int optional flags for the regular expression 0 Examples: IsAnyStr from dirty_equals import IsAnyStr assert 'foobar' == IsAnyStr () assert b 'foobar' == IsAnyStr () assert 123 != IsAnyStr () assert 'foobar' == IsAnyStr ( regex = 'foo...' ) assert 'foobar' == IsAnyStr ( regex = b 'foo...' ) # (1)! assert 'foobar' == IsAnyStr ( min_length = 6 ) assert 'foobar' != IsAnyStr ( min_length = 8 ) assert 'foobar' == IsAnyStr ( case = 'lower' ) assert 'Foobar' != IsAnyStr ( case = 'lower' ) regex can be either a string or bytes, IsAnyStr will take care of conversion so checks work.","title":"IsAnyStr"},{"location":"types/string/#dirty_equals.IsStr","text":"Bases: IsAnyStr [ str ] Checks if the value is a string, and optionally meets some constraints. IsStr is a subclass of IsAnyStr and therefore allows all the same arguments. Examples: IsStr from dirty_equals import IsStr assert 'foobar' == IsStr () assert b 'foobar' != IsStr () assert 'foobar' == IsStr ( regex = 'foo...' ) assert 'FOOBAR' == IsStr ( min_length = 5 , max_length = 10 , case = 'upper' )","title":"IsStr"},{"location":"types/string/#dirty_equals.IsBytes","text":"Bases: IsAnyStr [ bytes ] Checks if the value is a bytes object, and optionally meets some constraints. IsBytes is a subclass of IsAnyStr and therefore allows all the same arguments. Examples: IsBytes from dirty_equals import IsBytes assert b 'foobar' == IsBytes () assert 'foobar' != IsBytes () assert b 'foobar' == IsBytes ( regex = b 'foo...' ) assert b 'FOOBAR' == IsBytes ( min_length = 5 , max_length = 10 , case = 'upper' )","title":"IsBytes"}]}